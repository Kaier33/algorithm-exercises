### 前言
<<算法图解>>此书是一本入门级别的算法书籍, 代码量少, 且后期介绍的算法基本没有代码示例, 只有图文说明。 (换个说法, 就是对部分算法进行基本介绍)    

So, 不建议购买 23333 🤣

但是对于非科班的码农来说, 还是有些帮助的。    


#### 算法简介
1. 二分查找法的局限性: 仅当列表是有序的时候, 二分查找才管用
2. 介绍了大O表示法 (表示算法有多快)
3. 列出了常见几种大O运行时间的快慢比较
    + O(1) >  O(log n) > O(n) > O(n log n) > O(n²) > O(n!)

####  选择排序
1. 描述了 数组 和 链表 的区别
    + 数组的读取速度很快 O(1), 插入和删除较慢 O(n)
    + 链表的读取较慢 O(n), 插入和删除很快 O(1)

#### 递归
1. 栈: 先进后出 last in first out 
2. 使用 调用栈 演示了 递归 如何计算阶乘
3. 调用栈可能很长,这讲占用大量的内存
4. 每个递归函数都要有2个条件: 基线(终止)条件和递归条件
5. 递归只是让解决方案看起来更加清晰, 并没有性能上的优势, 循环的性能更好

#### 快速排序
1. 思路: 找准基, 分左右数组, 小于基准的在左, 大于反之. 最后 3个数组相加
2. 重点: 为了使快排的平均运行时间达到 O(n log n), 基准值必须随机选择

#### 散列表(散列隐射, 隐射, 字典和关联数组)
1. 散列表的查找, 插入,和删除速度都非常快(平均情况O(1), 极端情况为O(n))

#### 广度优先搜索(BFS)
1. BFS 算法能让你能找出两样东西之间的最短距离 (最短路径问题)
    + AI跳棋, 计算最少走多少步就可获胜
    + 根据你的人际关系网络找到关系最近的医生

#### 狄克斯特拉算法
1. 广度优先搜索用于在非加权图中查找最短路径
2. 狄克斯特拉算法用于在加权图中查找最短路径
3. 仅当权重为正时迪克斯拉特算法才管用
4. 如果图中包含负权边, 请使用 贝尔曼-福德算法

#### 贪婪算法
1. 贪婪算法寻找局部最优解, 企图以这种方式获得全局最优解
2. 对于NP完全问题, 还没有找到快速解决方案, 最佳的做法是使用近似算法(比如 贪婪算法)

#### 动态规划 DP
1. 需要在给定约束条件下优化某种指标时, 动态规划很有用
2. 问题可分解为离散子问题(子问题间无依赖关系), 可使用动态规划来解决
3. 每种动态规划解决方案都涉及网格
4. 每个单元格都是一个子问题, 因此你需要考虑如何将问题分解为子问题

#### K最近邻算法 KNN 
1. KNN用于分类和回归, 需要考虑最近的邻居
2. 分类就是编组
3. 回归就是预测结果(如数字)
4. 特征抽取意味着将物品(如水果或者用户)转换为一系列可比较的数字
5. 能否挑选合适的特征事关KNN算法的成败

#### 其他
1. 二叉查找树, B树, 红黑树, 伸展树
2. 反向索引(一个散列表, 将单词隐射到包含它的页面), 常用于创建搜索引擎
3. 傅里叶变换(一个优雅且应用广泛的算法), 如处理信号、图片、音乐识别, 地震预测和DNA分析等等
4. 并行算法 - 处理海量数据相关
    + 分布式计算 - Map-Reduce
    + 布隆过滤器 - 一种概率型数据结构, 它提供的答案有可能不对, 但很可能正确; 散列表虽然答案可靠,但是空间占用高
    + HyperLogLog - 类似布隆过滤器, 也是概率型算法, 占用的空间却少了很多
5. SHA算法
6. 线性规划